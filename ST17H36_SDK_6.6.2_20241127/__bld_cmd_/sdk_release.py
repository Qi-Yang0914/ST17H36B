#! /usr/bin/env python
import os
import shutil
import stat
import subprocess
import sys
import getopt
import platform
import time

import git
import yaml
import re
import cdk_api, keil_api, risv_api
# from cdk_api import get_bld_path_cdk, find_del_fold_cdk, get_dir_path_cdk
from keil_api import get_bld_path_keil, get_dir_path_keil, find_del_fold_keil, modify_version
from risv_api import get_dir_path_risv

locallocation = os.path.dirname(os.path.realpath(__file__))
locallocation = os.path.dirname(locallocation)

usage = 'Usage: sdk_release.py [--help] [--branch] [--tag] [--trunk] [--merge] [--release=......]\n' + \
        '[--mkbranch=......] [--mktag=......]\n'
optioninfo = '--help: help\n' + \
             '--branch: change branch,export a remote branch to local\n' + \
             '--trunk: download from git\n' + \
             '--merge: fetch + merge , make the local updated\n' + \
             '--release=\'commit test README14\': upload to git and add a commit message\n' + \
             '--mkbranch=\'branch name\': create a branch in remote, and upload files to this new-created branch\n' + \
             '--mkbranch (format --mkbranch \'branch name\')\n' + \
             '--mktag=\'tag name\': create a tag (format --mktag tagname SHA \'commit message\')\n' + \
             '--tag=\'tag name\' \'new branch name\': export a tag to local\n' + \
             '--rls=\'release config yaml\': export a tag to local push release remote repo\n' +\
             '--del=\'release config yaml\': delete the data generated by the test'
# '--2releaseR= \'TAG name\' \'build name\' \'cfg or None\' \'branch name\'\n' + \
helpstr = usage + optioninfo


# dest = 0

def check_dirs() -> int:
    """
    :return:
     check cdk-make.yml exist return 1
     check sdk_bld_tool.yml exist return 2
    """
    curpath = os.path.dirname(os.path.realpath("..\_bld_script\sdk_build.yml"))
    cdkyml = os.path.exists('..\_bld_script\cdk-make.yml')
    keilyml = os.path.exists('..\_bld_script\sdk_bld_tool.yml')
    riscvyml = os.path.exists('..\_bld_script\\riscv_make.yml')

    flg = 0

    if cdkyml:
        flg = 1
    elif keilyml:
        flg = 2
    elif riscvyml:
        flg = 3
    else:
        print("Error, Please check dirname!\n")
        pass

    return flg


def pyver():
    vstr = platform.python_version()
    vlist = vstr.split('.')
    if vlist[0] == '3':
        return 3
    return 2


def getcmd():
    if pyver() == 3:
        return input()
    return raw_input()


def validcmd(cmd):
    return os.system(cmd + ' 1>nul 2>nul')


def get_repo_branch_list(gitreleaseurl):
    now_version_info = os.popen(f'git ls-remote {gitreleaseurl}')
    now_version_info = now_version_info.buffer.read().decode('utf-8')
    now_version_list = now_version_info.split('\n')
    now_version = []
    for i in now_version_list:
        inf = i.split('\t')
        if len(inf) == 2:
            if 'refs/heads/' in inf[1]:
                inf1 = inf[1].split('/')
                now_version.append(inf1[2])
    return now_version


def branch_list() -> list:
    """
    :return:  list both remote-tracking and local branches
    """
    new_repo = git.Repo(locallocation)
    # print('all branches are listed below')
    branch = new_repo.git.branch('-a')
    branch = branch.split('\n')
    branchlist = []
    for s in branch:
        if 'remotes' in s and 'HEAD' not in s:  # head point to default branch
            ssub = s.split('/')
            ssub = ssub[len(ssub) - 1]
            branchlist.append(ssub)
        if '*' in s:
            pass
            # print('local branch is ', s.split(' ')[1])

    # print('branch list is :')
    # for i in range(len(branchlist)):
    # print(i, branchlist[i])
    return branchlist


def search_url():
    """
        return:yml fiel config
    """
    d = []
    curpath = os.path.dirname(os.path.realpath("..\_bld_script\sdk_build.yml"))

    dirs = check_dirs()
    if dirs == 1:
        yamlpath = os.path.join(curpath, 'cdk-make.yml')
    elif dirs == 2:
        yamlpath = os.path.join(curpath, 'sdk_bld_tool.yml')
    elif dirs == 3:
        yamlpath = os.path.join(curpath, 'riscv_make.yml')
    if os.path.exists(yamlpath):
        pass
    else:
        print('check file input--> search_url')
        return d
    f = open(yamlpath, 'r', encoding='utf-8')
    c = f.read()
    d = yaml.load(c, Loader=yaml.FullLoader)
    return d


def branch_chose():
    """
    1.check local project exist
    2.print all branchs
    """
    cfg = search_url()
    url = cfg['GitUrl']
    giturl = url[0]['git_url'][0]
    ret = 0
    if not os.path.exists(locallocation):
        print('no such folder')
        return

    branchlist = branch_list()
    print('Chose Branch: 0 -', len(branchlist) - 1)
    try:
        print('input branch number')
        branchNum = int(getcmd())  # number -1is the last one ,-2 is last but one .also can out of range
        ret = branchlist[branchNum]
    except:
        print("debug: branch_chose")
        print('Input out of range')
        exit()
    return ret  # ret will be a string


def branch_checkout(arg):
    """checkout branch"""
    new_repo = git.Repo(locallocation)
    new_repo.git.checkout(arg)  # subfiles all be updated when change to another branch

    # check the local branch now
    branch = new_repo.git.branch('-a')  # in clone file
    branch = branch.split('*')
    print('local branch now is', branch[1].split('\n')[0])
    return


def sha_finder():
    new_repo = git.Repo(locallocation)
    log_message = new_repo.git.log()
    log_SHA = log_message.split(' ')[1]
    log_SHA = log_SHA.split('\n')[0]

    return log_SHA


def rls_config(fname):
    """
    :pra:yml.ProtectFile.rls_example
    :retrun:projtct_dict
    """
    d = []
    curpath = os.path.dirname(os.path.realpath("..\_bld_script\sdk_build.yml"))

    yamlpath = os.path.join(curpath, fname + '.yml')
    if os.path.exists(yamlpath):
        pass
    else:
        print('check file input--> rls_confgi')
        return d
    f = open(yamlpath, 'r', encoding='utf-8')
    c = f.read()
    d = yaml.load(c, Loader=yaml.FullLoader)
    return d


def sdk_rls(args):
    cfg = rls_config(args[0])

    flg = search_url()
    url = flg['GitUrl']
    giturl = url[0]['git_url'][0]
    if len(url) != 2:
        gitmode = 2
    else:
        gitmode = 1

    if gitmode == 1:
        gitreleaseurl = url[1]['git_releaseurl'][0]
        print(' Url : %s \n giturl: %s \n gitreleaseurl: %s \n' % (
        url, url[0]['git_url'][0], url[1]['git_releaseurl'][0]))
    elif gitmode == 2:
        print(' Url : %s \n giturl: %s \n' % (url, url[0]['git_url'][0]))

    if len(cfg) == 0:
        print('check release config file !!!')
        return
    else:
        print(' Tag : %s \n Release Branch:%s \n BuildCofing:%s \n' % (
            cfg['ReleaseTagName'], cfg['ReleaseBranchName'], cfg['BuildConfig']))

    version = cfg['ReleaseBranchName'][0]
    versi = version.split('_')
    if gitmode == 1:
        if len(versi) < 3 or len(versi[2].split('.')) != 3:
            print(f'{version} version is not correct')
            return
        repo_branch_list = get_repo_branch_list(gitreleaseurl)
        for i in repo_branch_list:
            if modify_version(locallocation,i,mode=1) == modify_version(locallocation,version,mode=1):
                print(f'{version} version exists. Please modify it')
                return
        version_path = locallocation + '\\components\\inc\\version.h'
        if not os.path.exists(version_path):
            print('\\components\\inc\\version.h is not exits')
            return

    branch_list_a = branch_list()

    print("locallocation:", locallocation)
    new_repo = git.Repo(locallocation)

    print('build_first', cfg['BuildConfig'])

    # with modified sdk_build.yaml
    os.system('python .\sdk_build.py ' + '-l ' + cfg['BuildConfig'][0] + ' -b all')

    # find latest log file
    print('remove protect file')
    protectfile(cfg['ProtectFile'])
    # addfile = protectfile(cfg['ProtectFile'])
    print('build', cfg['BuildConfig'])

    # with modified sdk_build.yaml
    os.system('python .\sdk_build.py ' + '-l ' + cfg['BuildConfig'][0] + ' -b all')

    base_dir = locallocation + '\\__bld_cmd\\'
    filelist = os.listdir(base_dir)
    filelist.sort(key=lambda fn: os.path.getmtime(base_dir + fn) if not os.path.isdir(base_dir + fn) else 0)

    logfile = filelist[-1]
    print('latest file is', logfile)

    [err, warn, fail] = log_err_check(logfile)
    if err > 0 or fail > 4:
        print(f'!!! After compiling, there is error :{err}  and  fail: {fail}, please check the log file {logfile}')
        return
    if warn > 0:
        print(f'There is a warning during compilation,logfile is {logfile}. Please make sure to continue release [Y/N]')
        str1 = str(input())
        if str1 == 'Y':
            pass
        else:
            return
    if gitmode == 1:
        try:
            branch_name = cfg['ReleaseBranchName'][0]
            result = modify_version(locallocation, branch_name, mode=0)
            if result == False:
                print('modify version fail')
                return
        except Exception as e:
            print(e)

    try:
        print('tag is ', cfg['ReleaseTagName'])
        log_SHA = sha_finder()
        tag_args = [log_SHA, 'release tag']
        ret = tag_create(cfg['ReleaseTagName'][0], tag_args)
        if ret == False:
            print(f"\033[1;31;40mdebug: tag {cfg['ReleaseTagName'][0]} created failed\033[0m")
            return False
    except Exception as e:
        print("\033[1;31;40mdebug: create tag failed\033[0m")
        print(e)
        print("You need to enter the following command to fix the problem:\n"
              f"         git tag -d {tag_args}\n"
              "          The remote tag can be deleted from the web page")
        return False

    # add __bld_cmd souce code
    try:
        bld_path = locallocation + '\\__bld_cmd_'
        if os.path.exists(bld_path):
            shutil.rmtree(bld_path, onerror=remove_readonly)
            time.sleep(1)
        command = ['git', 'clone', 'git@192.168.1.11:gecko/__bld_cmd.git', bld_path]
        result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        if result.returncode != 0:
            print(f"Error cloning repository: {result.stderr}")
            return False
        git_bld_path = bld_path + '\\.git'
        shutil.rmtree(git_bld_path, onerror=remove_readonly)
    except Exception as e:
        print('add __bld_cmd fail')
        print(e)

    remote = new_repo.git.remote('--v')
    if gitmode == 2:
        gitreleaseurl = giturl
    if gitreleaseurl in remote:
        for i in range(len(remote.split('\n'))):
            # print(remote.split('\n')[i])
            # print(remote.split('\n')[i].split('\t')[1].split(' ')[0])
            if remote.split('\n')[i].split('\t')[1].split(' ')[0] == gitreleaseurl:
                new_origin = remote.split('\n')[i].split('\t')[0]  # remote url name already exist, take it
                print('the release reposity name is ', new_origin)
                break
    else:
        new_origin = 'release'
        try:
            new_repo.git.remote('add', new_origin, gitreleaseurl)  # origin2 is the name of release reposity
        except git.exc.GitCommandError as e:
            print('gitreleaseurl:' + gitreleaseurl + '\n' + 'new_origin:' + new_origin + '\n')
            print("\033[1;31;40mdebug: git remote failed\033[0m")
            print(e)
            print("You need to enter the following command to fix the problem:\n"
                  "         git  remote remove release")
            return False
    # elif gitmode == 2:
    #     pass

    try:
        branch_name = cfg['ReleaseBranchName'][0]
        # create local branch.will be pushed to release roposity#branch name with time
        # new_repo.git.branch('-D', branch_name)
        new_repo.git.checkout('--orphan', branch_name)
    except Exception as e:
        print("\033[1;31;40mdebug: git checkout branch failed \033[0m")
        print(e)
        print("You need to enter the following command to fix the problem:\n"
              "         git checkout master/main\n"
              "         git branch -D " + branch_name)
        return False

    try:
        os.system('git branch --set-upstream-to=' + new_origin + '/' + branch_name)
        os.chdir(locallocation)
        if len(cfg['ProtectFile']) >= 4:
            add_files = cfg['ProtectFile'][3]['add_files']
            for file in add_files:
                file_path = locallocation + '\\' + file
                if os.path.exists(file_path):
                    print('git add -f ' + file_path)
                    os.system('git add -f ' + file_path)
        # os.system('git push --set-upstream ' + new_origin + ' ' + branch_name)
        new_repo.git.add('.')
        new_repo.git.commit('-m', 'sdk release repo push')
        new_repo.git.push(new_origin, branch_name)
    except Exception as e:
        print("\033[1;31;40mdebug: git add, commit, push failed\033[0m")
        print(e)
        return False


def remove_readonly(func, path, _):
    # Remove readonly flag from the file.
    os.chmod(path, stat.S_IWRITE)
    func(path)


def log_err_check(fname):
    flog = open(fname, "r")
    flog.seek(0, 0)
    errnum, warnum, failnum = 0, 0, 0
    while True:
        logstr = flog.readline()
        if len(logstr) == 0:
            break  # read completed
        if logstr.find('Error(s)') > 0 and logstr.find('Warning(s)') > 0:
            errnum = errnum + int(logstr[logstr.find('-') + 1:logstr.find('Error(s)')])
            warnum = warnum + int(logstr[logstr.find('Error(s)') + 9: logstr.find('Warning(s)')])
        if logstr.find('prj build fail check _bld.txt') > 0:
            failnum = failnum + 1
    flog.close()
    return errnum, warnum, failnum


def export_sdk():
    """
    des: create sdk file and clone project
    """
    flg = search_url()
    # get git_url1
    url = flg['GitUrl']
    giturl = url[0]['git_url'][0]
    if os.path.exists(locallocation):
        if os.path.getsize(locallocation):
            print(os.path.getsize(locallocation))
            print('git file exist, no need to clone')
        else:
            # init git
            repo = git.Repo.init(path='.')
            new_repo = git.Repo.clone_from(url=giturl, to_path=locallocation)
    else:  # no folder
        os.mkdir(locallocation)  # create a folder
        repo = git.Repo.init(path='.')
        new_repo = git.Repo.clone_from(url=giturl, to_path=locallocation)

    print('protect code')
    # protectfile()#can repeat delete
    return 0


def sdk_merge():
    new_repo = git.Repo(locallocation)
    new_repo.git.pull()
    return 0


def find_del_fold_risv(bld, cur):
    delPath = []
    for a in cur:
        for b in bld:
            path = a + '\\'
            if path.endswith(b):
                delPath.append(a)
                break
    result_list = []
    for i in cur:
        if i not in delPath:
            result_list.append(i)

    return result_list


def find_attach_files_risv(a):
    locallocation = os.path.dirname(os.path.realpath(__file__))
    locallocation = os.path.dirname(locallocation)
    delPath = []
    for i in a:
        delPath.append(os.path.join(locallocation, i))

    return delPath

def get_bld_path_risv(bld,mode=0):
    bldList = []
    c_list = rls_config(bld)
    for p in c_list:
        lists = c_list[p][0]
        bldList.append(lists)
    return bldList


def protectfile(cfg):
    print('protect code')
    # print(cfg)

    dirs = check_dirs()
    if dirs == 1:
        print("this is CDK\n")
        bld = cdk_api.get_bld_path_cdk(cfg[0]['rls_example'][0])
        cur = cdk_api.get_dir_path_cdk(os.path.join(locallocation, 'example'), 3)
        remove_example = cdk_api.find_del_fold_cdk(bld, cur)
    elif dirs == 2:
        print("this is Keil\n")
        bld = get_bld_path_keil(rls_config(cfg[0]['rls_example'][0]))
        cur = get_dir_path_keil(os.path.join(locallocation, 'example'), 2)
        remove_example = find_del_fold_keil(bld, cur)
    elif dirs == 3:
        print("this is riscv\n")
        bld = get_bld_path_risv(cfg[0]['rls_example'][0],mode=1)
        cur = get_dir_path_risv(os.path.join(locallocation, 'example'), 2)
        remove_example = find_del_fold_risv(bld, cur)
    if remove_example is not None:
        print('remove_example')
        for del_path in remove_example:
            f_path = 'aliGenie_bleMesh'
            if f_path in del_path:
                print('del_path:', del_path)
            else:
                cmd = 'rd /s /q ' + del_path  # /q 安静模式下，/s 除目录本身外，还删除指定目录下的所有子目录和文件
                print(cmd)
                validcmd(cmd)
    if 'remove_folder' in cfg[2].keys():
        print('remove_folder')
        if cfg[2]['remove_folder'] is not None and cfg[2]['remove_folder'] != []:
            for del_path in cfg[2]['remove_folder']:
                # clone file cannot have a space inside
                libsrcpath = locallocation.split('/')[-1] + '\\' + del_path

                # rd means delete, s means project and subproject, q means no notification(quiet) then is the address
                cmd = 'rd /s /q ' + libsrcpath
                print(cmd)
                validcmd(cmd)  # os.system(cmd)
    if cfg[1]['remove_file'] is not None:
        print('remove_file')
        for del_path in cfg[1]['remove_file']:
            libsrcpath = locallocation.split('/')[-1] + '\\' + del_path  # clone file cannot have a space inside
            cmd = 'del /f /q ' + libsrcpath  # part of files will be deleted
            print(cmd)
            validcmd(cmd)  # os.system(cmd)

    return 0

def get_tag_list():
    new_repo = git.Repo(locallocation)
    tag_list = new_repo.git.tag('-l')
    tag_list = tag_list.split('\n')
    return tag_list



def release_tag_protectfile(cfg):
    print('protect code')
    # print(cfg)

    dirs = check_dirs()
    if dirs == 1:
        print("this is CDK\n")
        bld = cdk_api.get_bld_path_cdk(cfg[0]['rls_example'][0])
        cur = cdk_api.get_dir_path_cdk(os.path.join(locallocation, 'example'), 3)
        remove_example = cdk_api.find_del_fold_cdk(bld, cur)
        # attach_files = cdk_api.find_attach_files_cdk(bld, cur)
    elif dirs == 2:
        print("this is Keil\n")
        bld = get_bld_path_keil(rls_config(cfg[0]['rls_example'][0]))
        cur = get_dir_path_keil(os.path.join(locallocation, 'example'), 2)
        remove_example = find_del_fold_keil(bld, cur)
        # attach_files = cdk_api.find_attach_files_keil(bld, cur)
    elif dirs == 3:
        print("this is riscv\n")
        bld = get_bld_path_risv(cfg[0]['rls_example'][0])
        cur = get_dir_path_risv(os.path.join(locallocation, 'example'), 2)
        remove_example = find_del_fold_risv(bld, cur)
        # attach_files = find_attach_files_risv(cfg[-1]['attach_files'])
    if remove_example is not None:
        print('remove_example')
        for del_path in remove_example:
            f_path = 'aliGenie_bleMesh'
            if f_path in del_path:
                print('del_path:', del_path)
            else:
                cmd = 'rd /s /q ' + del_path  # /q 安静模式下，/s 除目录本身外，还删除指定目录下的所有子目录和文件
                print(cmd)
                # validcmd(cmd)
    if 'remove_folder' in cfg[2].keys():
        print('remove_folder')
        if cfg[2]['remove_folder'] is not None and cfg[2]['remove_folder'] != []:
            for del_path in cfg[2]['remove_folder']:
                # clone file cannot have a space inside
                libsrcpath = locallocation.split('/')[-1] + '\\' + del_path

                # rd means delete, s means project and subproject, q means no notification(quiet) then is the address
                cmd = 'rd /s /q ' + libsrcpath
                print(cmd)
    #             validcmd(cmd)  # os.system(cmd)
    if cfg[1]['remove_file'] is not None:
        print('remove_file')
        for del_path in cfg[1]['remove_file']:
            libsrcpath = locallocation.split('/')[-1] + '\\' + del_path  # clone file cannot have a space inside
            cmd = 'del /f /q ' + libsrcpath  # part of files will be deleted
            print(cmd)
    #         validcmd(cmd)  # os.system(cmd)

    return 0


def dele_test_data(cfg):
    new_repo = git.Repo(locallocation)
    dirs = check_dirs()
    cfg = rls_config(cfg[0])

    # tag_list = get_tag_list()
    # tag_name = cfg['ReleaseTagName'][0]
    # branch,tag,repo = 0,0,0
    # if tag_name in tag_list:
    #     tag = 1
    #     print(f'\nTag named: {tag_name} exists locally.')
    #
    #
    # branch_check = branch_list()[0]
    # branch_name = cfg['ReleaseBranchName'][0]
    # if branch_check == branch_name:
    #     branch = 1
    #     print(f'\nBranch named: {branch_name} exists locally.')
    #
    #
    # repo_info = new_repo.git.remote('--v')
    # repo_list = repo_info.split('\n')
    # for repo in repo_list:
    #     if repo.split('\t')[0] == 'release':
    #         repo = 1
    #         repo_name = repo.split("\t")[0]
    #         print(f'\nRepo named: {repo_name} exists locally.')
    #         repo_url = repo.split('\t')[1].split(' ')[0]
    #
    #
    # if branch == 1 or tag == 1 or repo == 1:
    #     if tag == 1:
    #         print(f'Do you want to delete the tag {tag_name}?')
    #     if branch == 1:
    #         print(f'Do you want to delete the branch {branch_name}?')
    #     if repo == 1:
    #         print(f'Do you want to delete the repo {repo_name} : {repo_url}?')
    #     print('Please make sure to delete [Y/N]')
    #     str1 = str(input())
    #
    #     if str1 == 'Y':
    #         pass
    #     else:
    #         pass

    # print('input id:')
    # id = int(input())

    ReleaseTagName = cfg['ReleaseTagName'][0]
    tag_delete(ReleaseTagName)

    ReleaseBranch = cfg['ReleaseBranchName'][0]
    print(f'======delete branch {ReleaseBranch}=======\n')
    branch_check = branch_list()[0]
    print(f"========git checkout {branch_check}========\n")
    new_repo.git.checkout('-B', branch_check)
    print(f'======delete local branch and release branch {ReleaseBranch}=======\n')
    try:
        new_repo.git.push('-d', 'release', ReleaseBranch)
        print(f'The branch: {ReleaseBranch} was deleted\n')
    except git.exc.GitCommandError as e:
        print(f'release branch {ReleaseBranch} not found.\n')
        # print(e)

    try:
        new_repo.git.branch('-D', ReleaseBranch)
    except git.exc.GitCommandError as e:
        print(f'local branch {ReleaseBranch} not found.\n')

    try:
        print(f'======delete release repo=======\n')
        new_repo.git.remote('rm', 'release')
    except git.exc.GitCommandError as e:
        print(f'release repo not found.\n')
        # print(e)


def branch_create(arg):
    new_repo = git.Repo(locallocation)

    branch = new_repo.git.branch('-a')  # in clone file
    if arg not in branch:
        new_repo.git.branch(arg)  # subfiles all be updated when change to another branch
    branch_checkout(arg)

    # upload files to this new branch
    new_repo.git.add('.')  # add all
    new_repo.git.push('--set-upstream', 'origin', arg)
    print('push successfully')
    return


def tag_delete(tag_name):
    try:
        new_repo = git.Repo(locallocation)
        new_repo.git.tag('-d', tag_name)
        new_repo.git.push('origin', ':refs/tags/' + tag_name)
        print('delete tag successful')
    except git.exc.GitCommandError as e:
        print(f"tag '{tag_name}' not found.")
    return


def tag_create(arg, args):
    new_repo = git.Repo(locallocation)
    tagname = arg
    print(args)
    if len(args) == 0:
        print('no arguments: SHA and commit message')
        print('no SHA value, go to git and find it')
        return False

    elif len(args) == 1:
        print('no commit message')
        return False

    SHA = args[0]
    msg = args[1]

    # if (msg == 'release tag'):
    # new_repo = git.Repo(dest)
    # remote = new_repo.git.remote('--v')
    # if gitreleaseurl in remote:
    # new_repo.git.fetch(gitreleaseurl)
    # new_repo.git.fetch(giturl)
    # else:
    # new_repo.git.fetch(giturl)

    new_repo.git.fetch('origin')
    alltag = new_repo.git.tag()
    if tagname in alltag:
        # tag_detail = new_repo.git.show(tagname)
        # tag_detail = new_repo.git.tag('-n')
        print('the same tag name already exist,change a name，use --mktag')
        return False
    if msg == 'release tag':
        new_repo.git.tag('-a', tagname, SHA, '-m', 'create a release tag')
    else:
        new_repo.git.tag('-a', tagname, SHA, '-m',
                         msg)  # git tag -a TAG4 4a9fc2769f17475c62768bb0a6bbc2fd81ecd593 -m 'a test for creating tag'
    new_repo.git.push('origin', 'tag', tagname)  # origin will change before calling this func
    alltag = new_repo.git.tag()
    if tagname in alltag:
        print('tag created and pushed to git successful')
        print("\033[1;33;40mCongratulations, you pushed the code successfully, is one of the few to get here.\033[0m")
        return True
    else:
        print('tag created failed')
        return False


def tag_checkout(arg, args):
    tag_name = arg
    branch_name = args[0]
    new_repo = git.Repo(locallocation)
    alltag = new_repo.git.tag()
    if tag_name not in alltag:
        print('tag name chose fail')
        return
    try:
        new_repo.git.checkout('-b', branch_name, tag_name)
    except Exception as e:
        print("\033[1;31;40mdebug: git checkout branch failed \033[0m")
        print(e)
        print("You need to enter the following command to fix the problem:\n"
              "         git checkout master/main\n"
              "         git branch -D " + branch_name)

    new_repo.git.push('--set-upstream', 'origin', branch_name)  # push new branch to remote
    new_repo.git.branch('--set-upstream-to=origin/' + branch_name,
                        branch_name)  # associate remote branch with local branch
    print('tag checkout successfully and you can make changes on new branch')
    print('tag checkout successfully & a new branch has been created starting from tag')

    return

def tag_release(args):
    cfg = rls_config(args)
    flg = search_url()
    if 'GitUrl' not in flg.keys():
        print('check release config file !!!')
        print('GitUrl Not Configured')
        return
    url = flg['GitUrl']
    giturl = url[0]['git_url'][0]
    if len(url) != 2:
        gitmode = 2
    else:
        gitmode = 1

    if gitmode == 1:
        gitreleaseurl = url[1]['git_releaseurl'][0]
        print(' Url : %s \n giturl: %s \n gitreleaseurl: %s \n' % (
            url, url[0]['git_url'][0], url[1]['git_releaseurl'][0]))
    elif gitmode == 2:
        print(' Url : %s \n giturl: %s \n' % (url, url[0]['git_url'][0]))

    if len(cfg) == 0:
        print('check release config file !!!')
        return
    else:
        print(' Tag : %s \n Release Branch:%s \n BuildCofing:%s \n' % (
            cfg['ReleaseTagName'], cfg['ReleaseBranchName'], cfg['BuildConfig']))

    version = cfg['ReleaseBranchName'][0]
    versi = version.split('_')
    if gitmode == 1:
        if len(versi) < 3 or len(versi[2].split('.')) != 3:
            print(f'{version} version is not correct')
            return
        repo_branch_list = get_repo_branch_list(gitreleaseurl)
        for i in repo_branch_list:
            if modify_version(locallocation, i, mode=1) == modify_version(locallocation, version, mode=1):
                print(f'{version} version exists. Please modify it')
                return
        version_path = locallocation + '\\components\\inc\\version.h'
        if not os.path.exists(version_path):
            print('\\components\\inc\\version.h is not exits')
            return

    print("locallocation:", locallocation)
    new_repo = git.Repo(locallocation)

    # with modified sdk_build.yaml
    os.system('python .\sdk_build.py ' + '-l ' + cfg['BuildConfig'][0] + ' -b all')

    base_dir = locallocation + '\\__bld_cmd\\'
    filelist = os.listdir(base_dir)
    filelist.sort(key=lambda fn: os.path.getmtime(base_dir + fn) if not os.path.isdir(base_dir + fn) else 0)

    logfile = filelist[-1]
    print('latest file is', logfile)
    attach_files = find_attach_files_risv(cfg['ProtectFile'][-1]['attach_files'])
    for i in attach_files:
        cmd = f"git add {i}"
        print(cmd)
        new_repo.git.add('-f',i)

    new_repo.git.commit('-m', 'add attach_files')
    tag_name = cfg['ReleaseTagName'][0]
    alltag = new_repo.git.tag()
    if tag_name in alltag:
        print('tag already exists')
        return
    try:
        print('create tag:', tag_name)

        new_repo.create_tag(tag_name)
        remote = new_repo.remote()
        print('push tag:', tag_name)
        remote.push(tag_name)
    except Exception as e:
        print(e)



def main(argv):
    global helpstr
    print(argv)

    if validcmd('git help') == 1:  # no git package
        print('please install command line client for GIT')
        return
    opts = []
    if len(argv) == 1:  # just run the python file
        print(helpstr)
        return
    try:
        opts, args = getopt.getopt(sys.argv[1:], 'h?',
                                   ['branch', 'merge', 'release=', 'rls', 'mkbranch=', 'mktag=', 'tag=', 'trunk',
                                    'help', 'dummy', 'del'])

    except:
        print("debug: main")
        print("getopt.getopt error")
        print(helpstr)
        return

    for opt, arg in opts:
        if opt in ('h', '--help', 'help'):
            print(helpstr)  # if there is 'help' in opts, print out help and return back
            return

    # not use
    if len(args) != 1:
        dest = '.\\release'  # release folder will be added into the path
    else:
        dest = '.\\' + args[0]  # add a new folder created by your argument

    for opt, arg in opts:
        print('opt and arg in opts are ')
        print(opt, arg)
        if opt[0] in ('h', '--help', 'help'):
            print(helpstr)
            return

        # checkout branch
        if opt == '--branch':
            arg = branch_chose()
            if (arg == None):
                print('no such folder,please export to local using --trunk first')
                break
            branch_checkout(arg)
            break

        elif opt == '--trunk':
            export_sdk()
            print('exported')
            break

        elif opt == '--merge':
            # git pull
            sdk_merge()
            print('merged')
            break

        elif opt == '--rls':
            if len(args) != 1:
                print('input release yaml file')
                break
            result = sdk_rls(args)
            cfg = rls_config(args[0])
            if result == False:
                print('\n\nIf an error occurs, run the following command:\n')
                print(f'    python .\sdk_release.py --del {args[0]}\n\n'
                      f'    This command will be deleted: \n'
                      f'      The tag already exists in the repository and local: {cfg["ReleaseTagName"][0]} \n'
                      f'      The branch already exists in the repository and local: {cfg["ReleaseBranchName"][0]} \n'
                      f'      The locally existing release repository')
                break
            break

        elif opt == '--del':
            print('Delete the data generated by the test,include:\n     A newly created local branch,\n'
                  '     Branch and tag of new key of remote warehouse')

            if len(args) != 1:
                print('input release yaml file')
                break
            dele_test_data(args)
            print('deleted Delete complete!!!!')
            break

        elif opt == '--mkbranch':
            if arg == '':
                print('you need to add a new branch name(format --mkbranch \'branch name\')')
                break
            branch_create(arg)
            print('new branch has been created and local repository uploaded to new branch')
            break

        elif opt == '--mktag':
            if arg == '' or args == '':
                print('you need to add a new tag name(format --mktag tag name SHA \'commit message\')')
                break
            tag_create(arg, args)
            break


        elif opt == '--tag':
            result = tag_release(arg)
            # new_repo = git.Repo(locallocation)
            # print('all tags are listed below')
            # tag_list = new_repo.git.tag()
            # print(tag_list)

            # if arg == '' or len(args) == 0:
            #     print('you need to add a tag name & a branch name(branch will be created later)')
            #     print('format --tag \'tag name\' branch_name')
            #     break
            #
            # if arg[1] == 'd':
            #     if len(arg) != 2:
            #         print('you need to add a branch name(format --tag \'tag name\' branch_name)')
            #         break
            #     tag_name = args[0]
            #     print('delete tag')
            #     tag_delete(tag_name)
            #     break
            #
            # print('branch name ', args[0])
            # # print(new_repo.git.branch())   #just local branch
            #
            # branchlist = branch_list()
            # print(branchlist)
            #
            # if args[0] in branchlist:
            #     print('branch exist. new one')
            #     # print('branch has been created,tag has been checkouted out')
            #     # print('now associate local branch with remote branch ')
            #     # new_repo.git.push('--set-upstream', 'origin', args[0]) #push new branch to remote
            #     # new_repo.git.branch('--set-upstream-to=origin', args[0])  # associate remote branch with local branch
            #     break
            # sdk_merge()  # pull down the new created tag from git
            # tag_checkout(arg, args)
            # break


        elif opt == '--release':
            if arg == '':
                # print('Error!: \"--release=version\", \"version\" could not be empty (version is tag name)')
                print('you need to add commit message(format --release \'commit message\')')
                return
            print('remove protect file(second time)')
            # protectfile() #double delete ensure no protected files
            new_repo = git.Repo(locallocation)
            new_repo.git.add('.')  # add all
            if len(new_repo.git.status('-s')) != 0:  # new change
                # new_repo.git.fetch()
                # if (new_repo.git.diff('newbranch','origin/newbranch')):
                sdk_merge()

                commit_step = new_repo.git.commit(m=arg)
                print(commit_step)  # need to judge if is something new-added)

                new_repo.git.push()

                # check if its  commit
                commitSHA = commit_step.split(' ')[1].split(']')[0]
                log_message = new_repo.git.log()
                log_SHA = log_message.split(' ')[1][:7]
                if commitSHA == log_SHA:
                    print('commit successful')
                else:
                    print('commit message not equal')
                # push successful
                branch = new_repo.git.branch('-a')  # in clone file
                branch = branch.split('*')
                print('local branch now is', branch[1].split('\n')[0])
                localbranch = branch[1].split('\n')[0]
                localbranch = localbranch.replace(' ', '')
                remotebranch = 'origin/' + localbranch
                remotebranch = remotebranch.replace(' ', '')
                if new_repo.git.diff(localbranch, remotebranch):
                    print('failed to push')
                else:
                    print('push successfully')
            else:
                print('nothing new to be added')
        break


if __name__ == '__main__':
    main(sys.argv)
